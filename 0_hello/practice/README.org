#+TITLE:Practice: C Programming Toolchain
#+AUTHOR:Marcus Birkenkrahe
#+SUBTITLE:Linux and GCC basics
#+STARTUP:overview hideblocks
#+OPTIONS: toc:nil num:nil ^:nil
* README

  * This directory contains practice material for the course.

  * This practice session deals with your C programming
    toolchain. Since we're working on Linux, you have many small,
    powerful UNIX commands available to you.

  * What you'll learn:
    - Finding out where you are on the computer
    - Climbing around the file system
    - Listing files
    - Downloading a file using FTP
    - Finding commands
    - Compiling a simple C source file
    - Running an executable file

  * Whenever you see this symbol: ~* [ ]~, you have something to do.

  * When you're in Emacs, put the cursor on the same line as the
    symbol and press ~C-c C-c~ then the symbol changes to ~* [X]~

  * [ ] Let's try this! Press ~C-c C-c~ a few times.

* Finding out where you are on the computer

  * To find out where you are, enter ~pwd~ ("print working directory")
    after the terminal prompt ~$~. In the example below, the answer is
    ~/home/pi~, which is the home directory of the user ~pi~.

    #+name: ex:pwd
    #+begin_example bash
    ~$ pwd
    /home/pi
    #+end_example

  * The answer to the shell command ~pwd~ is stored in the variable
    ~$PWD~. To check this, enter the command ~echo $PWD~ at the prompt.

    #+name: ex:pwd1
    #+begin_example bash
     ~$ echo $PWD
    /home/pi
    #+end_example

  * You can actually see this via the symbol ~ before the prompt,
    which stands for another variable, ~$HOME~.

  * [ ] Print the variable ~$HOME~.

    #+begin_src bash
      echo $HOME
    #+end_src

  * The shell, or ~bash(1)~, is a program that is capable of scripting,
    or programming both interactively (on the console/terminal/command
    line), or via stored scripts.

* Climbing around the file system

  * The computer has a list of locations stored where it checks for
    available programs - like an index - called the ~$PATH~.

  * [ ] Print the ~$PATH~ on your computer

    #+begin_src bash
      echo $PATH
    #+end_src

  * If it's not in the ~PATH~ list, the computer won't know it as a
    command. This includes executable files that you create yourself

  * To change directory, use ~cd~. E.g. ~cd ~~ or ~cd $HOME~ will get you to
    your home directory.

  * [ ] Go to your home directory and print the working directory. You
    can execute both commands in one go whe putting a ~;~ between them.

    #+name: cd
    #+begin_src bash
      cd ~ ; pwd
    #+end_src

    #+RESULTS:
    : /home/pi

  * [ ] Make another directory and go there (you could put all of
    these commands on one line separating them with semi-colons.

    #+begin_example bash
    mkdir -v test
    cd test
    pwd
    #+end_example
    (The ~-v~ flag means "verbose" - say what you just did).

  * To go to any place, you can enter ~cd~ followed by the location
    (or explicit path), e.g. ~/home/pi~ or ~/home/pi/test~, or by a
    relative path using ~..~

  * For example ~cd ..~ brings you back home from ~test~, while ~cd .~
    does nothing, and ~cd ../..~ gets you one directory up from ~pi~.

  * [ ] Follow this path using ~cd~:
    - Go back up one directory from ~/test~
    - Go back up one directory from ~/pi~
    - Go back up one directory from ~ (or ~/home~)
    - Go back down to ~/test~

* Listing files

  * The command ~ls~ lists all files in the current directory

  * ~ls~ also works with file paths, e.g. this listing of the directory
    ~$HOME~: 

    #+begin_src bash :results output
    ls /home/pi
    #+end_src

    #+RESULTS:
    #+begin_example
    bin
    Bookshelf
    csvkit_tutorial
    Desktop
    Documents
    Downloads
    GitHub
    Music
    Pictures
    Public
    src
    Templates
    test
    Videos
    #+end_example

  * [ ] This command has many useful options: try them yourself

    | COMMAND | LISTING           | WHAT?                                   |
    |---------+-------------------+-----------------------------------------|
    | ls -l   | long listing      | file owners, size, time, permissions    |
    | ls -a   | with hidden files | includes configuration files            |
    | ls -t   | time-ordered      | files sort by time of modification      |

    The example output for ~ls -l~ shows one file called ~README.org~ with
    permissions for the owner (~pi~) and his group (also called ~pi~) of
    size 6832 byte, last saved on May 14 at 18:38.

    #+begin_example
    -rw-r--r-- 1 pi pi 6382 May 14 18:38 README.org
    #+end_example

* TODO Downloading a file using FTP
* TODO Finding commands
* TODO Compiling a simple C source file
* TODO Running an executable file
* IN PROGRESS Glossary

  | TERM        | MEANING                 | WHAT?                            |
  |-------------+-------------------------+----------------------------------|
  | UNIX        | Operating system (OS)   | Enables your computing           |
  | Linux[fn:1] | Operating system (OS)   | Enables your computing           |
  | $PWD        | Print working directory | Where you are in the file system |
  | $HOME       | Hhome directory (~)     | Where your files are             |
  | Shell       | Connection to the OS    | e.g. ~bash~, scripting language    |
  | Prompt      | Command line symbol     | Enter shell commands after it    |
  | echo        | Displays its arguments  | e.g. ~echo hello~ prints ~hello~     |
  | variable    | Memory location         | Can be declared/re/defined       |
  | PATH        |                         |                                  |
  | mkdir       |                         |                                  |
  |             |                         |                                  |

* Footnotes

[fn:1]Linux comes in many shades and forms - because it is open
source, everyone can take it and make it to what he wants it to be. On
the Raspberry Pi, we use the Raspberry Pi OS, which is a Debian-style
operating system (the package manager is ~apt~).
